#!/usr/bin/env python
# (c) Copyright 2017 Jonathan Simmonds
"""search driver"""
import argparse
import inspect
import pkgutil
import sys
import os.path
from search_modules import *

__version__ = '1.0'

SEARCH_MODULES = globals()['modules']

class VerboseVersionAction(argparse.Action):
    def __init__(self, option_strings, dest, nargs=None, **kwargs):
        # this is how argparse initialises `prog` by default
        self.prog = os.path.basename(sys.argv[0])
        super(VerboseVersionAction, self).__init__(option_strings, dest, nargs=0, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        parser.exit(message='{} {}\n{}'.format(self.prog, __version__, self.version_string()))

    def version_string(self):
        return 'Copyright (c) 2017 Jonathan Simmonds\n\n' + \
               'Loaded modules:\n' + \
               '\n'.join(['  ' + str(m) for m in SEARCH_MODULES]) + \
               '\n'

def main():
    """Main method."""
    # Handle command line
    parser = argparse.ArgumentParser(description='Simple recursive file '
                                     'searcher.')
    parser.add_argument('--version', action=VerboseVersionAction,
                        help='show the version number of the program and its '
                        'installed modules and exit')
    parser.add_argument('-i', dest='ignore-case', action='store_const',
                        const=True, default=False,
                        help='Enable case-insensitive searching.')
    parser.add_argument('-v', dest='verbose', action='store_const',
                        const=True, default=False,
                        help='Enable verbose, full replication of the result '
                        'column, even if it means taking multiple lines per '
                        'match (by default the result will be condensed to '
                        'keep one line per match if possible).')
    parser.add_argument('path', type=str, default=[], nargs='*',
                        help='Optional path(s) to perform the search in or on. '
                        'If ommitted the current working directory is used.')
    parser.add_argument('regex', type=str,
                        help='Perl-style regular expression to search for. It '
                        'is recommended to pass this in single quotes to '
                        'prevent shell expansion/interpretation of the regex '
                        'characters.')
    args = parser.parse_args()

    print args

# Entry point.
if __name__ == '__main__':
    main()

